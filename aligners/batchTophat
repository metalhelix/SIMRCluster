#!/n/local/stage/perlbrew/perlbrew-0.43/perls/perl-5.16.0/bin/perl

=pod

=head1 batchTophat

  takes SIMR Lims directory and send fastq from samples for alignment in parallel using SGE

=head1 SYNOPSIS

  batchTophat [options] 
                 [--directories flowcell_1 flowcell_2...]
                 [--transcriptome-index aGenome_known_tc_tophat_idx | --GTF GTF/GFF_file]
                 [--bowtie2 aGenome_bowtie2_idx]
                 [-- any extra parameter to pass to tophat]
 Options:
  --help            brief help message
  --man             full documentation

  --destdir          destination dir to save the results (Def: ~/batchAlignement/aln_timeStamp)
  --sub_selection   smaller list of sample to use
  --exluded         sample to remove from the job

  --cpu             number of CPU per tophat jobs (Def: 4)
  --queue           SGE queue to use (Def: all.q)
  --pe              parallel environement (Def: by_node)

  --dryrun          print the jobs that will be sent to SGE

 Every options names can be abreviated to their smaller unique value (ie: -dir/--directories, -de/--destdir)

=head1 REQUIRED ARGUMENTS

=over 8

=item B<--directories>

Path to the location of a flowcells containting the fastq and the .csv file describing the samples (Generated by the SIMR LIMS system).
Multiple diretories can be passed (seperated by space)

=item B<--bowtie2>

Path to the root of the bowtie2 index. if the shell environment varibale BOWTIE2_TX_INDEXES exists poiting to directory containing the index exits, only the name of prefiex name of the index is required.

=back

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=item B<-directories>

Path to the location of a flowcells containting the fastq and the .csv file describing the samples (Generated by the SIMR LIMS system).
Multiple diretories can be passed (seperated by space)

=item B<--transcriptome-index | --GTF>

Index name or path to a pre-built transcriptome inded or the location of the GTF file to built the transcriptome index. if the shell environment varibale TOPHAT_TX_INDEXES exists poiting to directory containing the index exits, only the name of prefiex name of the index is required.

=item B<-cpu>

Define the number of CPU to run tophat (in fact, the bowtie2 aligment) and the number of slots per node requested
to the SGE manager. I found that there is no net gain in using the full hyperthreaded cores, on a dual quad-core cpu (8 cpu total),
treal time is same at -cpu 4 or -cpu 8. There is a ~20% increase in real time if two 4 cpu jobs are run concurently on a
8 cpu node, so overall,still a significant increase in performance if two jobs run on the same nodes. This is why, the default
is set at 4 cpu (half the dual core)

=item B<-dryrun>

Prints the jobs that will be run without exuting them

=back

=head1 DESCRIPTION

B<This program> will read the SIMR Lims generated directories of flowcells barcode
in search of a file with the .csv extension (the Sample_Report.csv and other iteration previously used by the lims).
It will then use the sample name (in column 1) and associates the coressponding fastq file(s) (in column 3), one sample 
to many fastq files, even if located accross flowcells (as long as the flowcell directories are passed as argument to --directories).

Then, the fastq file(s) will be passed to tophat and multiple alignment jobs will be sent to the SGE queue, using a 
parallel environment allowing shared memory (all slot assing to a job has to reside on a single node, look for 
a parallel environment using the B<allocation_rules> = $pe_slots or integers >= then your requested CPU number.

The results will be saved indivually named subdirecories using the sample named inside the TopHat_aln directories.
The --dest-dir can be use to define a location to save the results, otherwise, the ~/batchAligment direcory
will be created and each individual runs saved with the local time of the run as name.

=head1 EXAMPLES

./batchTophat --dir test --bowtie Drosophila_melanogaster.BDGP5.71.min  --trans Drosophila_melanogaster.BDGP5.71.min.tc --dest temp

./batchTophat --dir test --bowtie Drosophila_melanogaster.BDGP5.71.min  --trans Drosophila_melanogaster.BDGP5.71.min.tc --sub C587UAS-CD8GFPmaelVDRC100907-1 C587UAS-CD8GFParmiVDRC16206-3 --dest temp

./batchTophat --dryrun --cpu 4 --bowtie Drosophila_melanogaster.BDGP5.71.min --trans Drosophila_melanogaster.BDGP5.71.min.tc --dir /n/analysis/Si/jsg/MOLNG-150/C0TNYACXX/ /n/analysis/Si/jsg/MOLNG-194/D10KJACXX /n/analysis/Si/jsg/MOLNG-194/C0TD0ACXX/ /n/analysis/Si/jsg/MOLNG-194/C11LJACXX/ -dest ~/aln/Si_memory_analysis

~/scripts/aligner/batchTophat  --bowtie Drosophila_melanogaster.BDGP5.71.min --trans Drosophila_melanogaster.BDGP5.71.min.tc --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX /n/analysis/Blanchette/sha/MOLNG-61/C0K08ACXX --destdir Sex_n_Tudor

=cut

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path remove_tree);
use POSIX qw/strftime/;
use Getopt::Long;
use Pod::Usage;
use Cwd;
use File::Spec::Functions;

our ($man,$help,$debug,$dryrun,@prog_args);
our (@dirs,$ebwt,$tx_idx,$gtf,$DESTDIR,@sub_select,@excluded,$extra);
our ($cpu,$queue,$pe);

our $aligner = 'tophat';

MAIN:{
  init();
  my $start = time();
  testIndex();
  my %res = getSample2Files();

  qsub_align(%res);

  
  my $end =time();
  my $sec = $end - $start;
  printf("Aligments was done in  %d hours,%d mins and %d seconds\n",int($sec/(60*60)),($sec/60)%60,$sec%60) unless $dryrun;
  print("Results will be found in $DESTDIR\n") unless $dryrun;
  exit 0;
}

sub testIndex{
  my $ori_tx_idx = $tx_idx;
  my $ori_ebwt = $ebwt;

  ## Expand tilde to full path, 
  $tx_idx =~ s/~/$ENV{HOME}/;
  $ebwt =~ s/~/$ENV{HOME}/;
  
  unless (-e "$tx_idx.gff"){
    if (exists $ENV{TOPHAT_TX_INDEXES}){
      $ENV{TOPHAT_TX_INDEXES} =~ s/~/$ENV{HOME}/;
      $tx_idx = -e "$ENV{TOPHAT_TX_INDEXES}/$tx_idx.gff" ? 
	"$ENV{TOPHAT_TX_INDEXES}/$tx_idx" : undef;
    } else {
      $tx_idx = undef;
    }
  }
  
  unless (-e "$ebwt.1.bt2"){
    if (exists $ENV{BOWTIE2_INDEXES}){
      $ENV{BOWTIE2_INDEXES} =~ s/~/$ENV{HOME}/;
      $ebwt = -e "$ENV{BOWTIE2_INDEXES}/$ebwt.1.bt2" ? 
	"$ENV{BOWTIE2_INDEXES}/$ebwt" : undef;
    } else {
      $ebwt = undef;
    }
  }
  
  die "Can't find tohat transcript index $ori_tx_idx\n" unless $tx_idx;
  die "Can't find bowtie2 transcript index $ori_ebwt\n" unless $ebwt;
  
}

sub getSample2Files {
  my %res2;
  
  for my $dir (@dirs){
    $dir = File::Spec->rel2abs($dir);
    
    my ($csv,@rest) = glob "$dir/*.csv";
    die " there is more than one CSV file in $dir->[0]" if @rest;
    
    open FH, $csv;
    my($filename, $dir, $suffix) = fileparse($csv);
    my ($f_i,$s_i,%res);
    while (<FH>){
       chomp;
       my @line = split /,/;
       if($. == 1){
	 ($f_i) = grep{$line[$_] eq 'output'} 0..$#line;
	 ($s_i) = grep{$line[$_] eq 'sample name'} 0..$#line;
	 next;
       }
       $res{$line[$f_i]} = $line[$s_i];
     }
    my @fastq = map{File::Spec->rel2abs($_)} glob "${dir}*[ACGT].fastq.gz";
    
    my %excluded = map{$_,1} @excluded if @excluded;
    
    @fastq = grep{!exists $excluded{$_}} @fastq;
    
    for my $path (@fastq){
      my($file) = fileparse($path);
      
      if (!exists $res{$file}){
        print STDERR "$file is not associated with a sample name\n";
      } else {
        push @{$res2{$res{$file}}},$path
      }
    }
  }

  if (@sub_select){
    my %sub = map{$_=>1} @sub_select;
    %res2 = map{$_=>$res2{$_}} grep{exists $sub{$_}} keys %res2;
  }
  
  return %res2
}

sub qsub_align{
  my %res = @_;
  my %jobs = createAlnJobs(\%res);
  ## Sending the alignment to the SGE queue
  print ">>> Aligning the fasq files\n>>>>>>>>>>\n\n";
  spinQsub(\%jobs,'align') unless $debug;

  my $bam_dir = "$DESTDIR/bam";
  make_path($bam_dir) unless $dryrun;
  
  symlink("../tophat_aln/$_/accepted_hits.bam","$bam_dir/$_.bam") for keys %jobs;
  
  %jobs = indexBams(\%res,$bam_dir);
  spinQsub(\%jobs,'index') unless $debug;
}

sub indexBams {
  my %res = %{shift()};
  my $bam_dir = shift;
  my %jobs = map{($_,"samtools index $bam_dir/$_.bam")} keys %res;
  return %jobs;
}

sub createAlnJobs {
  my %res = %{shift()};
  
  my %jobs;
  for my $exp (keys %res){
    my @fastq = @{$res{$exp}};
    
    my $res_dir = "$DESTDIR/tophat_aln/$exp";
    make_path($res_dir) unless $dryrun;
    
    my $align = "tophat";
    $align   .= " -p$cpu";
    $align   .= " --transcriptome-index=$tx_idx" if $tx_idx;
    $align   .= " --GTF=$gtf" if $gtf;
    $align   .= " -o $res_dir";
    $align   .= " --no-coverage-search";
    $align   .= " $extra";
    $align   .= " $ebwt";
    $align   .= " ".join(",",@{$res{$exp}});
    
    $jobs{$exp} = $align;
  }
  return(%jobs)
}

sub spinQsub {
  my %jobs = %{shift()};
  my $type = shift();
  
  $type ||= '';
    
  
  my $sge_out = "$DESTDIR/SGE_out";
  make_path($sge_out) unless $dryrun;
  
  my (@job_ids,$i);
  for my $exp (keys %jobs){
    
    my $com = "qsub";
    $com   .= " -l mem_free=4G";
    $com   .= " -j y -o $sge_out";
    $com   .= " -pe $pe $cpu";
    $com   .= " -q $queue";
    $com   .= " -N ${type}_$exp";
    $com   .= " -V";
    $com   .= " -cwd";
    $com   .= " -terse";
    $com   .= " -b y";
    $com   .= " '$jobs{$exp}'";
    
    print "$com\n";
    print "============>>>\n";
    
    next if $dryrun;
    
    open my $qsub,"-|",$com;
    while (<$qsub>){chomp;push @job_ids,$_};
    close $qsub;

  }
  
  return if $dryrun;
  
  ### Create a qrsh dependent on the submited job waiting to join
  ### Prevents from returning before the alignments are done
  print "Waiting on jobs to finish\n";
  my $end = 'qrsh';
  $end   .= ' -now y';
  $end   .= ' -hold_jid '.join ",",@job_ids;
  $end   .= " 'echo Done!'";
  system $end;
}

sub init {
  my $filename = basename($0);
  @prog_args = ($filename,@ARGV);
  print("Running as:\n",
	join(" ",@prog_args),"\n",
	">>>>>>\n\n"
       );

  GetOptions('debug'                 => \$debug,
	     'help|?'                => \$help,
	     'man'                   => \$man,
	     
	     'directories=s{,}'      => \@dirs,
	     'bowtie2=s'             => \$ebwt,
	     'transcriptome-index=s' => \$tx_idx,
	     'GTF=s'                 => \$gtf,
	     'destdir=s'             => \$DESTDIR,

	     'excluded=s{,}'         => \@excluded,
	     'sub_selection=s{,}'    => \@sub_select,
	     
	     'cpu=i'                 => \$cpu,
	     'queue=s'               => \$queue,
	     'pe=s'                  => \$pe,
	     'dryrun'                => \$dryrun
	    ) or pod2usage(1);

  if ($help || !(@dirs && $ebwt)){
    pod2usage(-exitstatus => 0, -verbose => 2);
  }elsif ($man){
    pod2usage(-exitstatus => 0, -verbose => 0);
  }

  $cpu     ||= 4;
  $queue   ||= 'all.q';
  $pe      ||= 'by_node';
  $extra = join(' ',@ARGV);
  
  $DESTDIR ||= strftime('bowtieBatch_%Y-%m-%d_%H%M%S',localtime);
  make_path($DESTDIR) unless (-e $DESTDIR && -d $DESTDIR) || $dryrun;
  
  print STDERR "##########RUNNING IN DEBUGING MODE##########\n" if $debug;
}
__END__
