#!/n/local/stage/perlbrew/perlbrew-0.43/perls/perl-5.16.0/bin/perl

=pod

=head1 batchAlignment

  takes SIMR Lims directory and send fastq from samples for alignment in parallel using SGE

=head1 SYNOPSIS

  batchBowtie2 [options] 
               [--bowtie2 bowtie_index]
               [--directories flowcell_1 flowcell_2 ...]
               [-- any extra parameter to pass to bowtie]

 Options:
  --help            brief help message
  --man             full documentation

  --destdir         destination dir to save the results (Def: ~/batchAlignement/aln_timeStamp)
  --sub_selection   smaller list of sample to use
  --excluded         sample to remove from the job

  --queue           SGE queue to use (Def: all.q)

  --dryrun          print the jobs that will be sent to SGE

 Every options names can be abreviated to their smaller unique value (ie: -dir/--directories, -de/--destdir)

=head1 REQUIRED ARGUMENTS

=over 8

=item B<--directories>

Path to the location of a flowcells containting the fastq and the .csv file describing the samples (Generated by the SIMR LIMS system).
Multiple diretories can be passed (seperated by space)

=item B<--bowtie2>

Path to the root of the bowtie2 index. If the environment variable BOWTIE2_TX_INDEXES exists and points to the directory containing the bowtie2 indexes, only the name of the index can be provide

=back

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--destdir>

Name and location of the directory where the final bam files will be located

=item B<--dryrun>

Prints the jobs that will be run without exuting them

=item B<--sub_selection>

smaller list of sample to use
  
=item B<--excluded>

sample to remove from the job

=item B<--queue>

SGE queue to use (Def: all.q)

=item B<-->

Additional paramter to pass to bowtie. Will be taken literally. Need to be encloseed in double quotes with internal double quotes properly escaped.
For instance:

-- "-N 2 -k5 --ignore-quals"

will be added as is to the bowtie parameter list. Currenlty, bowtie2 is run with no extra arguments.

=back

=head1 DESCRIPTION

B<This program> will read the SIMR Lims generated directories of flowcells barcodes
in search of a file with the .csv extension (the Sample_Report.csv and other iteration previously used by the lims).
It will then use the sample name (in column 1) and associates the coressponding fastq file(s) (in column 3), one sample 
to many fastq files, even if located accross flowcells (as long as the flowcell directories are passed as argument to --directories).

Then, the fastq file(s) will be split in a tmp directory and aligned in parallel using bowtie2 using jobs sent
to the SGE queue. The mulitple bam files will then be merged and the results will be saved indivually as .bam files
using the sample named in hte .csv files The --dest-dir can be use to define a location to save the results,
otherwise, the ./bowtieBatch_DD/MM/YY:H:M:S directory will be created and will store the final bam files.

=head1 EXAMPLES

B<Dry Run>: Printing what will be run without runing it
~/scripts/aligner/batchBowtie2 --dryrun --bowtie Drosophila_melanogaster.BDGP5.71.min --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX /n/analysis/Blanchette/sha/MOLNG-61/C0K08ACXX --destdir Sex_n_Tudor'

B<Running>:
~/scripts/aligner/batchBowtie2 --bowtie Drosophila_melanogaster.BDGP5.71.min --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX /n/analysis/Blanchette/sha/MOLNG-61/C0K08ACXX --destdir Sex_n_Tudor'

B<debugging>
~/scripts/aligner/batchBowtie2 --bowtie Drosophila_melanogaster.BDGP5.71.min --dir /n/analysis/Blanchette/sha/MOLNG-61/C05HTACXX --destdir temp --debug

~/scripts/aligner/batchBowtie2 --bowtie Drosophila_melanogaster.BDGP5.71.min --dir test  --destdir temp
=cut

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path remove_tree);
use POSIX qw/strftime/;
use Getopt::Long;
use Pod::Usage;
use Cwd;
use File::Spec::Functions;

our ($man,$help,$debug,$dryrun,@prog_args);
our (@dirs,$ebwt,$extra,$DESTDIR,@sub_select,@excluded);
our ($queue);

our $aligner = 'bowtie2';

MAIN:{
  init();
  my $start = time();
  testIndex();
  my %res = getSample2Files();
  
  qsub_align(%res);
  
  my $end =time();
  my $sec = $end - $start;
  printf("Aligment request done in  %d hours,%d mins and %d seconds\n",
	 int($sec/(60*60)),($sec/60)%60,$sec%60) unless $dryrun;
  print("Results will be found in $DESTDIR\n") unless $dryrun;
  exit 0;
}

sub testIndex{
  my $ori_ebwt = $ebwt;
  ## Expand tilde to full path, 
  $ebwt =~ s/~/$ENV{HOME}/;
  unless (-e "$ebwt.1.bt2"){
    if (exists $ENV{BOWTIE2_INDEXES}){
      $ENV{BOWTIE2_INDEXES} =~ s/~/$ENV{HOME}/;
      $ebwt = -e "$ENV{BOWTIE2_INDEXES}/$ebwt.1.bt2" ? 
	"$ENV{BOWTIE2_INDEXES}/$ebwt" : undef;
    } else {
      $ebwt = undef;
    }
  }
  
  die "Can't find bowtie2 transcript index $ori_ebwt\n" unless $ebwt;
  
}

sub getSample2Files {
  my %res2;
  
  for my $dir (@dirs){
    $dir = File::Spec->rel2abs($dir);
    
    my ($csv,@rest) = glob "$dir/*.csv";
    die " there is more than one CSV file in $dir->[0]" if @rest;
    
    open FH, $csv;
    my($filename, $dir, $suffix) = fileparse($csv);
    my ($f_i,$s_i,%res);
    while (<FH>){
      chomp;
      my @line = split /,/;
       if($. == 1){
	 ($f_i) = grep{$line[$_] eq 'output'} 0..$#line;
	 ($s_i) = grep{$line[$_] eq 'sample name'} 0..$#line;
	 next;
       }
      $res{$line[$f_i]} = $line[$s_i];
    }
    my @fastq = map{File::Spec->rel2abs($_)} glob "${dir}*[ACGT].fastq.gz";
    
    my %excluded = map{$_,1} @excluded if @excluded;
    
    @fastq = grep{!exists $excluded{$_}} @fastq;
    
    for my $path (@fastq){
      my($file) = fileparse($path);
      
      if (!exists $res{$file}){
        print STDERR "$file is not associated with a sample name\n";
      } else {
        push @{$res2{$res{$file}}},$path
      }
    }
  }
  if (@sub_select){
    my %sub = map{$_=>1} @sub_select;
    %res2 = map{$_=>$res2{$_}} grep{exists $sub{$_}} keys %res2;
  }
  return %res2
}

sub qsub_align{
  my %res = @_;
  
  my %fastq_dir = splitFile(%res);
  
  my @fastqs;
  for my $exp (keys %fastq_dir) {
    opendir(my $dh, $fastq_dir{$exp}) || die "can't opendir $fastq_dir{$exp}: $!";
    push @fastqs,grep{/$exp\.\d+$/} readdir($dh);
    closedir $dh;
  }

  ## This is to make sure that there is no fastq files that have not been processed
  ## This loops will run untill there is no more item in @fastqs
  ## Their is a test to make sure all fastq files exists as bams
  ## TODO -->> Should make sure the file is non-empty if exists
  while(@fastqs){
    ## Creating the list of jobs
    my %jobs = createAlnJobs(\@fastqs,\%fastq_dir);
    
    ## Sending the alignment to the SGE queue
    print ">>> Aligning the fasq files\n>>>>>>>>>>\n\n";
    spinQsub(\%jobs,'align') unless $debug;
    
    ## Testing to see if all fastqs have made it into bams
    my %bams;
    for my $exp (keys %fastq_dir){
      my $bam_dir = "$fastq_dir{$exp}/bam";
      opendir(my $dh, $bam_dir) || die "can't opendir $bam_dir: $!";
      map{$bams{$_}=1} grep{/$exp\.\d+/} readdir($dh);
      closedir $dh;
    }
    
    @fastqs = grep{!exists $bams{"$_.bam"} } @fastqs;
    @fastqs = '' if $dryrun;
  } 
  
  mergeBams(%fastq_dir);
  
  ### Cleanup
  remove_tree(dirname($fastq_dir{$_})) for keys %fastq_dir;
  
  print ">>>>> Indexing the bam files\n>>>>>>>>>>\n\n";
  my %jobs = indexBams(\%fastq_dir,$DESTDIR);
  spinQsub(\%jobs,'index') unless $debug;
  
}

sub createAlnJobs {
  my @fastq = @{shift()};
  my %fastq_dir = %{shift()};
  
  my %jobs;
  for my $f (@fastq){
    my ($exp) = ($f =~ /(.+)\.\d+$/);
    
    my $bam_dir = "$fastq_dir{$exp}/bam";
    make_path($bam_dir) unless $dryrun;
    
    my $align = join(" ",
		     "$aligner",
		     "-x $ebwt",
		     "-p1",
		     "$extra",
		     "$fastq_dir{$exp}/$f",
		     "|samtools view -S -b - |samtools sort -o - temp > $bam_dir/$f.bam"
		    );
    
    $jobs{$f} = $align;
  }
  return(%jobs)
}

sub mergeBams {
  my %fastq_dir = @_;

  my %jobs;
  for my $exp (keys %fastq_dir){
    my $bam_dir = "$fastq_dir{$exp}/bam";
    my $final_bam = "$DESTDIR/${exp}.bam";
    my @bams = glob "$bam_dir/*.bam";
    if (scalar @bams > 1){
      $jobs{$exp} = "samtools merge -f - $bam_dir/*.bam > $final_bam";
    } else {
      $jobs{$exp} = "mv $bam_dir/*.bam $final_bam";
    }
  }
  print ">>>> Merging the bamfiles\n>>>>>>>>>>\n\n";
  spinQsub(\%jobs,'merge') unless $debug;
}

sub splitFile {
  my %res = @_;
  
  my %jobs;
  my %fastq_dirs;
  
  for my $exp (keys %res) {
    my $tmp_dir = "$DESTDIR/$exp/tmp";
    $fastq_dirs{$exp} =  $tmp_dir;
    make_path($tmp_dir) unless $dryrun;
    
    my $job = "split -l 10000000 -d -a4";

    ## Testing wether we deall with gzip or plain file (well... by the extension...)
    my @gz = grep {/\.gz$/} @{$res{$exp}};
    unless (@gz){
      $job .= "$job @{$res{$exp}}";
    } elsif (scalar @gz == scalar @{$res{$exp}}){
      my $fastqs = join(",",@gz);
      $job = "gunzip -c $fastqs |  $job - $tmp_dir/$exp.";
    } else {
      print STDERR "Can't deal with a mixture of .gz and plain text fastq file";
      next;
    }
    $jobs{$exp} = $job;
  }
  print ">>>> Splitting the fastq files\n>>>>>>>>>>\n\n";
  spinQsub(\%jobs,'split') unless $debug;
  return(%fastq_dirs);
}

sub indexBams {
  my %res = %{shift()};
  my $bam_dir = shift;
  my %jobs = map{($_,"samtools index $bam_dir/$_.bam")} keys %res;
  return %jobs;
}

sub spinQsub {
  my %jobs = %{shift()};
  my $type = shift();
  $type ||= '';
  
  my $sge_out = "$DESTDIR/SGE_out";
  make_path($sge_out) unless $dryrun;
  
  my (@job_ids,$i);
  for my $exp (keys %jobs){
    my $com = join(" ",
		   "qsub",
		   "-l mem_free=3G",
		   "-j y -o $sge_out",
		   "-q $queue",
		   "-N ${type}_$exp",
		   "-V",
		   "-cwd",
		   "-terse",
		   "-b y",
		   "'$jobs{$exp}'"
		   );
    
    print "$com\n";
    print "============>>>\n";
    
    next if $dryrun;
    
    open my $qsub,"-|",$com;
    while (<$qsub>){chomp;push @job_ids,$_};
    close $qsub;
  }
  return if $dryrun;
  ### Create a qrsh dependent on the submited job waiting to join
  ### Prevents from returning before the alignments are done
  print "Waiting on jobs to finish\n";
  my $end = join(" ",
		 "qrsh",
		 "-now y",
		 "-hold_jid ".join(",",@job_ids),
		 "'echo Done!'"
		);
    system $end;
}

sub init {
  my $filename = basename($0);
  @prog_args = ($filename,@ARGV);
  print("Running as:\n",
	join(" ",@prog_args),"\n",
	">>>>>>\n\n"
       );

  GetOptions('debug'                 => \$debug,
	     'help|?'                => \$help,
	     'man'                   => \$man,
	     
	     'directories=s{,}'      => \@dirs,
	     'bowtie2=s'             => \$ebwt,
	     'destdir=s'             => \$DESTDIR,
	     
	     'excluded=s{,}'         => \@excluded,
	     'sub_selection=s{,}'    => \@sub_select,
	     
	     'queue=s'               => \$queue,
	     'dryrun'                => \$dryrun
	    ) or pod2usage(1);

  if ($help || !(@dirs && $ebwt)){
    pod2usage(-exitstatus => 0, -verbose => 2);
  }elsif ($man){
    pod2usage(-exitstatus => 0, -verbose => 0);
  }

  $queue   ||= 'all.q';

  $extra = join(' ',@ARGV);
  
  $DESTDIR ||= strftime('bowtieBatch_%Y-%m-%d_%H%M%S',localtime);
  make_path($DESTDIR) unless (-e $DESTDIR && -d $DESTDIR) || $dryrun;
  
  print STDERR "##########RUNNING IN DEBUGING MODE##########\n" if $debug;
}
__END__
